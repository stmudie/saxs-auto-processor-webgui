from gevent import monkey; monkey.patch_all()
import gevent
from socketio import socketio_manage
from socketio.server import SocketIOServer
from socketio.namespace import BaseNamespace
from time import sleep, time
from flask import Flask, request, send_file, render_template
import cPickle as pickle
import redis
from os.path import basename

app = Flask(__name__)

app.debug = True

redisObj = redis.StrictRedis(host='10.138.11.70', port=6379, db=0)

attributes = { 'nicknames': [] }


class GraphNamespace(BaseNamespace):

    def checkForNewRedisProfile(self):
        self.sub = redisObj.pubsub()
        subChannels = redisObj.smembers('logline:channels')
        self.sub.subscribe(subChannels)
        zeros = [0]*len(subChannels)
        print 'listening'
        lastTimeSent = dict(zip(subChannels, zeros))
        for message in self.sub.listen():
            print 'Message from channel %s' %(message['channel'],)
            if (message['type'] != 'message'):
                print 'Wrong message type: %s' %(message['type'],)
                continue
            try:
                if time()-lastTimeSent[message['channel']] < 0.5:
                    continue
                data = pickle.loads(message['data'])
                filename = basename(data['filename'])
                fullProfile =[element for element in data['profile'] if element[1]>0]
                self.emit(message['channel'].split(':')[-1],{'filename':filename,'profile':fullProfile})
                lastTimeSent[message['channel']] = time()
            except Exception, e:
                print 'There was an exception in checkForNewRedisProfile: %s' %(e,)

    def recv_connect(self):
        #channels = redisObj.smembers('logline:channels')
        #channels = [channel.split(:)[0] for channel in channels]
        #redisObj.get()
        g = self.spawn(self.checkForNewRedisProfile)
        
    
    def recv_disconnect(self):
        self.sub.unsubscribe()
        self.kill_local_jobs()
        print 'disconnect'

    def recv_message(self, message):
        print "PING!!!", message

@app.route("/socket.io/<path:path>")
def run_socketio(path):
    socketio_manage(request.environ, {'/graph': GraphNamespace}, attributes)
    return ''

@app.route("/")
def login():
    return render_template("graphSAXS.html")

if __name__ == '__main__':
    print 'Listening on port 80 and on port 843 (flash policy server)'
    SocketIOServer(('0.0.0.0', 80), app).serve_forever()
